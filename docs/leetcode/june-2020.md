没想到每日一题又延长了一个月。

| 一                                                                               | 二                                                   | 三                                                   | 四                                                                    | 五                                                                         | 六                                                                   | 日                        |
| -------------------------------------------------------------------------------- | ---------------------------------------------------- | ---------------------------------------------------- | --------------------------------------------------------------------- | -------------------------------------------------------------------------- | -------------------------------------------------------------------- | ------------------------- |
| [1 ✅](https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies) | [2 ✅](https://leetcode-cn.com/problems/qiu-12n-lcof) | [3 ✅](https://leetcode-cn.com/problems/new-21-game/) | [4 ✅](https://leetcode-cn.com/problems/product-of-array-except-self/) | [5 ✅](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/) | [6 ✅](https://leetcode-cn.com/problems/longest-consecutive-sequence) | 7                         |
| 8                                                                                | 9                                                    | 10                                                   | 11                                                                    | 12                                                                         | 13                                                                   | 14                        |
| 15                                                                               | 16                                                   | 17                                                   | 18                                                                    | 19                                                                         | 20                                                                   | 21                        |
| 22                                                                               | 23                                                   | 24                                                   | 25                                                                    | 26                                                                         | 27                                                                   | 28                        |
| 29                                                                               | 30                                                   | <font color=gray>1</font>                            | <font color=gray>2</font>                                             | <font color=gray>3</font>                                                  | <font color=gray>4</font>                                            | <font color=gray>5</font> |

## 1. 求 1+2+…+n

!> [面试题64](https://leetcode-cn.com/problems/qiu-12n-lcof/). 求1+2+…+n

> 剑指 Offer 中的题，之前做过。题目要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。

这是很有意思的一道题目。若无上述限制，要完成这道题可以有三种做法：等差数列求和，迭代和递归。然而题目规定不能使用乘除和循环语句，因此剩下递归可用，但题目又规定不能使用条件判断语句，那么如何判停呢？

利用逻辑运算符的**短路效应**，
- 「与 `&&`」。`if(A && B)`，若 A 为 false ，则 B 的判断不会执行，直接判定 A && B 为 false
- 「或 `||`」。`if(A || B)`，若 A 为 true ，则 B 的判断不会执行，直接判定 A || B 为 true

我们需要在 `n == 1` 时终止递归，那判停语句为：`boolean b = (n > 1) && ((sum = n + sumNums(n - 1)) > 0)`，为构成语句，需要添加一个 `boolean b`；由于 `&&` 右边本身为 `int` 所以需要一个加一个判断条件变为 `boolean`。

```java
public int sumNums(int n) {
    int sum = n;
    boolean b = (n > 1) && ((sum = n + sumNums(n - 1)) > 0);
    return sum;
}
```

评论区看到另一种递归做法：

```java
int[] test = new int[]{0};
public int sumNums(int n) {
    try {
        return test[n];
    } catch(Exception e) {
        return n + sumNums(n - 1);
    }
}
```

[官方题解](https://leetcode-cn.com/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/)中还有一种「快速乘」的解法。

## 2. ⭐ 新 21 点

!> [837](https://leetcode-cn.com/problems/new-21-game/). 新21点

> 想不到思路 0.0。题解给出动规方法，以下摘自[题解](https://leetcode-cn.com/problems/new-21-game/solution/xin-21dian-by-leetcode-solution/)


爱丽丝获胜的概率只和下一轮开始前的得分有关，因此令 $dp[x]$ 表示从得分为 $x$ 的情况开始游戏并且获胜的概率，目标是求 $dp[0]$ 的值。

根据规则，当分数达到或超过 $K$ 时游戏结束，此时：
- 若分数不超过 $N$ 则获胜。有 $dp[x] = 1 \quad K \leq x \leq \min (N, K+W-1)$。若 $K - 1$ 时抽到的数为 $W$，且 $K - 1 + W < N$，因此有 $min (N, K+W-1)$。
- 若分数超过 $N$ 则失败。有 $dp[x] = 0 \quad x>\min (N, K+W-1)$。

当 $0 \leq x < K$ 时，如何计算 $dp[x]$ 的值？注意到每次在范围 $[1, W]$ 内随机抽取一个整数，且每个整数被抽取到的概率相等，因此可以得到如下状态转移方程：

$$dp[x]=\frac{dp[x+1]+dp[x+2]+\cdots+dp[x+W]}{W}$$

上述解法在 $0 \leq x < K$ 时，比较费时，需要优化。考虑对 $dp$ 的相邻项计算差分并移项<font color="#c0c0c0" size="2">（偏数学了）</font>，有如下结果：

$$dp[x]=dp[x+1]-\frac{dp[x+W+1]-dp[x+1]}{W}$$

其中 $0 \leq x < K - 1$，我们需要对 $dp[K - 1]$ 单独计算：

$$dp[K-1]=\frac{dp[K]+dp[K+1]+\cdots+dp[K+W-1]}{W}$$

注意到只有当 $K \leq x\leq \min(N, K+W-1)$ 时才有 $dp[x]=1$，因此

$$dp[K-1]=\frac{\min (N, K+W-1)-K+1}{W}=\frac{\min (N-K+1, W)}{W}$$

可在 $O(1)$ 内计算出 $dp[K - 1]$。对于 $dp[K-2]$ 到 $dp[0]$ 的值，则可通过新的状态转移方程得到。

[代码](https://github.com/JingqingLin/LeetCode/blob/master/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%20-%202020.06/837.%20%E6%96%B021%E7%82%B9/src/Solution.java)

## 3. 除自身以外数组的乘积

!> [238](https://leetcode-cn.com/problems/product-of-array-except-self/). 除自身以外数组的乘积

> 题目要求不能使用除法，且在 $O(n)$ 时间复杂度内完成此题。

每个位置的结果，为 $它左边的数的乘积 * 它右边的数的乘积$。那么我们用**两个数组**来保存每个位置左边所有数的乘积和右边所有数的乘积即可。

> **进阶**：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）

由于输出数组不被视为额外空间，我们可以暂时用它来存储*左边的数的乘积*，对于右边数的乘积 $R$，我们可以用一个常数来记录，在倒序遍历 `nums[]` 时，更新 $R$ 和输出数组。

```java
public static int[] productExceptSelf(int[] nums) {
    int n = nums.length;
    int[] product = new int[n];
    
    product[0] = 1;
    for (int i = 1; i < n; i++) {
        product[i] = product[i - 1] * nums[i - 1];
    }
    
    int R = 1;
    for (int i = n - 1; i >= 0; i--) {
        product[i] = product[i] * R;
        R *= nums[i];
    }
    return product;
}
```

## 4. 顺时针打印矩阵

!> [面试题29](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/). 顺时针打印矩阵

### 模拟

定义一个“方向”数组 `int[][] direction = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}` 来控制遍历方向，当下一个位置超出边界或者已访问（设一个 `boolean[][] hasVisited` 数组）时，就改变方向。

定义一个 `i` 来记录已遍历的元素数量，并根据总的元素数量来判断是否结束遍历。

### 按层模拟

> 参考自[题解](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shun-shi-zhen-da-yin-ju-zhen-by-leetcode-solution/)

可以将矩阵看成若干层，首先打印最外层的元素，其次打印次外层的元素，直到打印最内层的元素。下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。

```java
[[1, 1, 1, 1, 1, 1, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 2, 3, 3, 3, 2, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 1, 1, 1, 1, 1, 1]]
```

按下图遍历每一层：

![](_images/june-4-1.png ':class=image-80')

遍历完当前层的元素之后，将 left 和 top 分别增加 1，将 right 和 bottom 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止，终止条件为 `left > right || top > bottom`。

## 5. ⭐ 最长连续序列

!> [128](https://leetcode-cn.com/problems/longest-consecutive-sequence/). 最长连续序列（困难）

> 给定一个未排序的整数数组，找出最长连续序列的长度。**要求算法的时间复杂度为 $O(n)$**。

用哈希表存储每个端点值对应连续区间的长度，*摘自力扣评论区*。
- 若数 `num` 已在哈希表中，则跳过
- 若不在哈希表中，
    - 取出其左右相邻数已有的连续区间长度 `leftLen` 和 `rightLen`
    - 计算当前数的区间长度为：`curLen = leftLen + rightLen + 1`
    - 根据 `curLen` 更新最大长度 `maxLen` 的值
    - **更新**区间**两端点**的长度值，即更新 `num - leftLen` 和 `num + rightLen` 的在哈希表中的值
