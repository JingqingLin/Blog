<center>
<img src="https://cdn.jsdelivr.net/gh/JingqingLin/Blog/docs/leetcode/_images/daily-challenges.png" alt="每日一题" width="70%"/>
</center>

力扣<a href="https://leetcode-cn.com/problemset/2020-05/" target="_blank">每日一题：5 月</a>（部分）。

| 一                                                                                                                  | 二                                                                                                                    | 三                                                                                                                                                     | 四                                                                                                                       | 五                                                                                                                                                   | 六                                                                                                                                       | 日                                                                                                                                 |
| ------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| <font color=gray>27</font>                                                                                          | <font color=gray>28</font>                                                                                            | <font color=gray>29</font>                                                                                                                             | <font color=gray>30</font>                                                                                               | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank">1✅</a>                                     | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank">2✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank">3✅</a>                         |
| <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/jump-game-ii" target="_blank">4✅</a>              | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank">5✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/minimum-cost-for-tickets" target="_blank">6✅</a>                                     | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/subtree-of-another-tree" target="_blank">7✅</a>        | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/maximal-square" target="_blank">8✅</a>                                             | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/sqrtx" target="_blank">9✅</a>                                          | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree" target="_blank">10✅</a> |
| <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/powx-n" target="_blank">11✅</a>                   | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/min-stack" target="_blank">12✅</a>                  | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank">13✅</a>                           | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/single-number" target="_blank">14✅</a>                 | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/subarray-sum-equals-k" target="_blank">15✅</a>                                     | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank">16✅</a>                      | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/course-schedule-ii" target="_blank">17✅</a>                      |
| <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/maximum-product-subarray" target="_blank">18✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/valid-palindrome-ii" target="_blank">19✅</a>        | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts" target="_blank">20✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank">21✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank">22✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/minimum-window-substring" target="_blank">23✅</a>                      | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank">24✅</a>             |
| 25                                                                                                                  | 26                                                                                                                    | 27                                                                                                                                                     | 28                                                                                                                       | 29                                                                                                                                                   | 30                                                                                                                                       | 31                                                                                                                                 |

## 1. 无重复字符的最长子串

!> [3](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/). 无重复字符的最长子串

之前做过，👉 [传送门](leetcode/1-10?id=_3-无重复字符的最长子串)

## 2. 最大子序和

!> [53](https://leetcode-cn.com/problems/maximum-subarray/). 最大子序和

贪心思想专题做过，👉 [传送门](leetcode/贪心思想?id=_53)

## 3. 跳跃游戏 II

!> [45](https://leetcode-cn.com/problems/jump-game-ii/). 跳跃游戏 II

> 相关问题：[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

### BFS
把能跳到的位置加入队列，并维护 BFS 的层数，若最后一个点入队，返回层数

此题用 BFS 会超时，但[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)中可以通过

![](_images/may-3-1.png)

### 贪心
在[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)中，只需判断是否能够跳跃到终点，那么可以这样处理这个问题：

> 依次遍历数组中的每一个位置，并**实时**维护**最远可以到达的位置**。
>
> 对于当前遍历到的位置 $x$，如果它在**最远可以到达的位置**的范围内，那么就可以从某点通过若干次跳跃到达该位置，因此可以用 $x + nums[x]$ 更新最远可以到达的位置；如果它超出了**最远可以到达的位置**，则无法到达终点。
>
> 代码如下：
> ```java
> public static boolean canJump(int[] nums) {
>     int n = nums.length;
>     int rightMost = 0;
>     for (int i = 0; i < n; ++i) {
>         if (i <= rightMost) {
>             rightMost = Math.max(rightMost, i + nums[i]);
>             if (rightMost >= n - 1) {
>                 return true;
>             }
>         } else {
>             break;
>         }
>     }
>     return false;
> }
> ```

而此题与上题唯一的不同之处是需要计算最短跳跃次数。那么需要维护一个数组，该数组记录了到达每个位置的最短跳跃次数。

如何更新最短跳跃次数的数组？假设当遍历到位置 `i` 时，最远距离 `rightMost` 被更新，那么，更新该数组 `[i + 1, rightMost]` 区间内的值，若 `cnt[i] + 1` 大于原数组的值，则不更新，见代码

```java
public int jump(int[] nums) {
    int n = nums.length;
    int rightMost = 0;
    int[] cnt = new int[n];
    for (int i = 0; i < n; ++i) {
        if (i <= rightMost) {
            if (rightMost < i + nums[i]) {
                rightMost = i + nums[i];
                for (int j = i + 1; j <= rightMost && j < n; j++) {
                    cnt[j] = cnt[j] == 0 ? cnt[i] + 1 : Math.min(cnt[i] + 1, cnt[j]);
                }
            }
            if (rightMost >= n - 1) {
                return cnt[n - 1];
            }
        } else {
            break;
        }
    }
    return 0;
}
```

## 4. 验证二叉搜索树

!> [98](https://leetcode-cn.com/problems/validate-binary-search-tree/). 验证二叉搜索树

有两种思路：
1. 根据二叉搜索树中序遍历为升序的特性来判断
2. 递归

中序遍历思路较清晰，此处对“递归法”进行解释。

对于二叉搜索树中某结点，**左子树所有节点小于它；右子树所有结点大于它**。因此递归时，设置两个参数 `upper` 和 `lower` 代表左右子树的数值区间（开区间）。

如何确定区间的值：

- 对左子树进行递归时，`lower` 不变，`upper` 变为当前结点的值
- 对右子树进行递归时，`upper` 不变，`lower` 变为当前结点的值

代码如下：

```java
public static boolean isValidBST(TreeNode root) {
    return recursion(root, Long.MIN_VALUE, Long.MAX_VALUE);
}

public static boolean recursion(TreeNode node, Long lower, Long upper) {
    if (node == null) {
        return true;
    }
    if (node.val <= lower || node.val >= upper) {
        return false;
    }
    if (!recursion(node.right, (long) node.val, upper) || !recursion(node.left, lower, (long) node.val)) {
        return false;
    }
    return true;
}
```

力扣的测试用例中，出现了 Integer 边界值的测试用例（若区间初值为 Integer 的边界值，则对于 `[2147483647]` 会返回 false），所以将左右区间范围改为 Long 的区间

## 5. ⭐ 最低票价

!> [983](https://leetcode-cn.com/problems/minimum-cost-for-tickets/). 最低票价

> 第一想法是完全背包问题，没思路，看了题解，可以从前往后 dp

$dp[i]$ 表示第 $i$ 天最便宜的花费

转移方程：

$dp[i]=\left\lbrace\begin{array}{ll} dp[i-1] && i ∉ days[] \cr \min (dp[i - 1] + cost[0], dp[i - 7] + cost[1], dp[i - 30] + cost[2]) && i ∈ days[] \end{array}\right.$  

```java
public static int mincostTickets(int[] days, int[]costs) {
    int lastDay = days[days.length - 1];
    int[] dp = new int[lastDay + 1];
    int index = 0;
    for (int i = 1; i <= lastDay; i++) {
        if (i == days[index]) {
            int day1 = i - 1;
            int day2 = Math.max(i - 7, 0);
            int day3 = Math.max(i - 30, 0);
            dp[i] = Math.min(dp[day1] + costs[0], Math.min(dp[day2] + costs[1], dp[day3] + costs[2]));
            index++;
        } else {
            // 如果这一天不是必须出行的日期，选择不买票
            dp[i] = dp[i - 1];
        }
    }
    return dp[lastDay];
}
```

## 6. 另一个树的子树

!> [572](https://leetcode-cn.com/problems/subtree-of-another-tree/). 另一个树的子树

和剑指 Offer 中 [面试题26](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/). 树的子结构 思路相同（但此题中的示例 2，则剑指 Offer 中是 true）

用 DFS 可实现，`isSubtree` 函数中枚举 s 中的每一个节点，判断这个点的子树是否和树 t 相等，`isSameTree` 里进行具体比较（两次 DFS）

```java
public class Solution {
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) {
            val = x;
        }
    }

    public static boolean isSubtree(TreeNode s, TreeNode t) {
        if (t == null) {
            return true;
        }
        if (s == null) {
            return false;
        }
        return isSameTree(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
    }

    private static boolean isSameTree(TreeNode s, TreeNode t) {
        if (s == null && t == null) {
            return true;
        }
        if (s == null || t == null) {
            return false;
        }
        if (s.val != t.val) {
            return false;
        }
        return isSameTree(s.left, t.left) && isSameTree(s.right, t.right);
    }
}
```

## 7. ⭐ 最大正方形

!> [221](https://leetcode-cn.com/problems/maximal-square/). 最大正方形

动态规划专题做过，👉 [传送门](leetcode/动态规划?id=_1-⭐-最大正方形)


## 8. x 的平方根

!> [69](https://leetcode-cn.com/problems/sqrtx/). x 的平方根

二分查找专题做过，👉 [传送门](leetcode/二分查找?id=_1-x-的平方根)


## 9.⭐ 二叉树的最近公共祖先

!> [236](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/). 二叉树的最近公共祖先

可以用哈希表存两条路径上的结点，若 contains 了，说明为公共结点，代码写得很烂。https://paste.ubuntu.com/p/qyYXRgQXkQ/

官方题解的两种方法都很巧妙。👍 **递归法**[题解](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/)

## 10. Pow(x, n)

!> [50](https://leetcode-cn.com/problems/powx-n/). Pow(x, n)

直接算超时，用**快速幂**，see [题解](https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/)，递归的方式实现比较直观，迭代法要想一想

## 11. 最小栈

!> [155](https://leetcode-cn.com/problems/min-stack/). 最小栈

辅助栈记录最小元素：
- 若当前 push 元素小于等于辅助栈栈顶元素，则压入辅助栈
- 若当前 pop 元素等于辅助栈栈顶元素，则弹出辅助栈

`LinkedList` 相当于双向链表，可用它来模拟队列或栈

注意：`LinkedList` 中的 `push` 是将元素插入列表的前面，压栈应该用 `addLast`

## 12. 只出现一次的数字

!> [136](https://leetcode-cn.com/problems/single-number/). 只出现一次的数字

> 本题为「[面试题56 - I](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/). 数组中数字出现的次数」的简化版本，此题题解[传送门](leetcode/april-2020?id=_21-⭐-数组中数字出现的次数)

对于异或，我们有一个性质：$x = x \oplus y \oplus y$。那么对整个数组进行异或，最后的结果即为出现一次的数字。

## 13. 和为 K 的子数组

!> [560](https://leetcode-cn.com/problems/subarray-sum-equals-k/). 和为K的子数组

> 第一反应是排序 + 滑动窗口。仔细阅读题目后，发现要求子数组连续且数组中有负数。因此思路转向前缀和

### 枚举

以 `nums = [1, 1, 1], k = 2` 为例：

[过程动画](may-2020-13-screencast.mp4 ':include :type=iframe width=100% height=500px')


```java
public static int subarraySum(int[] nums, int k) {
    int count = 0;
    for (int start = 0; start < nums.length; ++start) {
        int sum = 0;
        for (int end = start; end >= 0; --end) {
            sum += nums[end];
            if (sum == k) {
                count++;
            }
        }
    }
    return count;
}
```

时间复杂度为 $O(n^2)$

### 前缀和 + 哈希表优化

把前缀和存到哈希表里，就不用每次都加了

```java
public static int subarraySum(int[] nums, int k) {
    int count = 0, pre = 0;
    HashMap<Integer, Integer> mp = new HashMap<>();
    mp.put(0, 1);
    for (int i = 0; i < nums.length; i++) {
        pre += nums[i];
        if (mp.containsKey(pre - k)) {
            count += mp.get(pre - k);
        }
        mp.put(pre, mp.getOrDefault(pre, 0) + 1);
    }
}
```

时间复杂度为 $O(n)$

## 14. K 个一组翻转链表

!> [25](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/). K 个一组翻转链表（困难）

首先，整条链表的反转比较简单，看这里复习 👉 [传送门](https://leetcode-cn.com/problems/reverse-linked-list/)，分组链表反转的难点在于：
1. 若最后一组不满足 k 个如何不反转
2. 每组首尾如何相接

解决办法：
1. 使用快慢指针，快慢指针相差 k 个结点，若快指针为 null 说明最后一组不反转
2. 额外创建结点，记录每组的“尾巴”和下一组的“头部”，当遍历完一组后把“尾头”它们相连

代码[在此](https://paste.ubuntu.com/p/qcM6qj28BY/)

## 15. ⭐ 课程表 II

!> [210](https://leetcode-cn.com/problems/course-schedule-ii/). 课程表 II

> 考查**拓扑排序**知识，之前没做过此类题目。除拓扑排序外，有向无环图的另一个应用是关键路径

看这篇题解 👍：https://leetcode-cn.com/problems/course-schedule-ii/solution/bao-mu-shi-ti-jie-tuo-bu-pai-xu-si-lu-zen-yao-yi-2/

## 16. ⭐ 乘积最大子数组

!> [152](https://leetcode-cn.com/problems/maximum-product-subarray/). 乘积最大子数组

> 动态规划思想比较容易想到，关键在于如何处理负数的问题

参考自[官方题解](https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution/)：

如果我们用 $dp_{max}$ 表示以第 $i$ 个元素**结尾**的乘积最大子数组的乘积，那么可以推出状态转移方程：

$dp_{max}[i] = \max(dp_{max}[i - 1] * nums[i], nums[i])$

求出所有的 $dp_{max}$ 之后选取最大的一个作为答案。

**可是我们发现上述方程，仅对负数个数为 0 个或 1 个的数组有效。**因为当前位置的最优解未必是由前一个位置的最优解转移得到的。比如：$nums = \{ 1, 2, -3, 4, -5 \}$，当遍历到 $-5$ 时，$-5$ 与*前一个位置结尾的乘积的*___最小值___相乘才能得到最终的答案。所以上述定义并不满足「最优子结构」。

**我们可以根据正负性进行分类讨论。**

考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。于是这里我们可以再维护一个 $dp_{min}$，它表示以第 $i$ 个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：

$dp_{max}[i] = \max(dp_{max}[i - 1] * nums[i], dp_{min}[i - 1] * nums[i], nums[i]) \\ dp_{min}[i] = \min(dp_{max}[i - 1] * nums[i], dp_{min}[i - 1] * nums[i], nums[i])$

求出所有的 $dp_{max}$ 之后选取最大的一个作为答案。

## 17. 验证回文字符串 Ⅱ

!> [680](https://leetcode-cn.com/problems/valid-palindrome-ii/). 验证回文字符串 Ⅱ（简单）

之前做过，👉 [传送门](leetcode/双指针#_3-验证回文字符串-Ⅱ)

## 18. 💣 每个元音包含偶数次的最长子字符串

!> [1371](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/). 每个元音包含偶数次的最长子字符串

### 前缀和 + 状态压缩

思路比较巧妙，直接看[题解](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/c-qian-zhui-he-zhuang-tai-ya-suo-xiang-jie-by-yizh/)和[代码](https://paste.ubuntu.com/p/xHHrmFBN2B/)。<font color=#C0C0C0>需要注意无元音字母的情况。</font>

## 19. 最长回文子串

!> [5](https://leetcode-cn.com/problems/longest-palindromic-substring/). 最长回文子串

之前做过，可以用动态规划求解，👉 [传送门](leetcode/1-10?id=_5-最长回文子串)

## 20. ⭐ 从前序与中序遍历序列构造二叉树

!> [105](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/). 从前序与中序遍历序列构造二叉树

剑指 Offer 的原题 👉 [传送门](lcof/lcof?id=面试题07-⭐-重建二叉树)，很好地考查了树的遍历。

## 21. 最小覆盖子串

!> [76](https://leetcode-cn.com/problems/minimum-window-substring/). 最小覆盖子串（困难）

> 考查滑动窗口思想

![](_images/may-21-1.gif)

<font color=#C0C0C0>gif 来自[力扣题解](https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/)</font>

我们在 $s$ 上滑动窗口，通过移动 $r$ 指针不断扩张窗口。当窗口包含 $t$ 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。

如何判断当前的窗口包含所有 $t$ 所需的字符呢？我们可以用一个哈希表表示 $t$ 中所有的字符以及它们的个数，用另一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 $t$ 的哈希表中的所有字符，并且对应的个数都不小于 $t$ 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。

[代码](https://paste.ubuntu.com/p/QCzDrbkrJ6/)

## 22. 💣 寻找两个有序数组的中位数

!> [4](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/). 寻找两个有序数组的中位数（困难）

又是一道 hard，此题可以用二分思想解，之前做过，👉 [传送门](leetcode/1-10?id=_4-💣-寻找两个有序数组的中位数)