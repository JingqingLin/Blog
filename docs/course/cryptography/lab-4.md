?> RSA 中公开的模数 N

## 实验内容

> 【时间】6 月 13 号（周六）晚上
> 
> 【地点】待定
> 
> 【编程语言】Python（推荐）或者 C/C++
>
> 【实验目的】
> 1. 了解公钥加密方案的一般结构；
> 2. 深入理解 RSA 加密原语的密钥生成；
> 3. 通过使用 Python（推荐）或者 C，编程实现对没有正确生成密钥的 RSA 的破解，提醒大家不要尝试自己随意实现加密原语。
>
> 【实验内容】
> 实验内容和要求请见附件 [EXP4-Doc.pdf](course/cryptography/lab-4-EXP4-Doc.pdf ':ignore')

## 实验准备

本实验拟采用 C++ 作为编程语言。同实验二，本实验也需要配置 GMP 库，详细配置过程见[实验二](course/cryptography/lab-2?id=windows-下配置-gmp)相应部分或以下网页片段。

[实验二配置 GMP](https://jingqinglin.github.io/Blog/#/course/cryptography/gmp-config ':include :type=iframe width=100% height=600px')

## 实验分析

### 实验要求

通常，构成 RSA 模数 $N$ 的素数 $p$ 和 $q$ 应该被独立地产生。但是，假设一个开发者决定通过选择一个随机数 $R$，并搜索其附近的两个素数作为 $p$ 和 $q$。那么，我们来证明这种方法得到的  RSA  的模数 $N = pq$ 能被轻易的分解。

假设给定一个合数 $N$ 并知道 $N$ 是两个彼此很接近的素数 $p$ 和 $q$ 的乘积，我们的任务是分解 $N$。

- **任务 1**：模数 $N$ 是两个素数 $p$ 和 $q$ 的乘积，满足$|p-q|<2 N^{1/4}$。（模数 $N$ 请见附件 [task.txt](course/cryptography/lab-4-task.txt ':ignore')）
- **任务 2**：模数 $N$ 是两个素数 $p$ 和 $q$ 的乘积，满足$|p-q|<2^{11} N^{1/4}$。（模数 $N$ 请见附件 [task.txt](course/cryptography/lab-4-task.txt ':ignore')）。*提示*：在 $A-\sqrt{N}<2^{20}$ 的情况下，尝试从 $\sqrt{N}$ 向上搜索 $A$，直到成功地分解 $N$。

### 任务 1

### 任务 2

完整代码 👉 [传送门](course/cryptography/lab-4-solution ':target=_blank')

## 实验结果

运行代码，有以下结果：

```cpp
Task 1:
p: 13407807929942597099574024998205846127479365820592393377723561443721764030073662768891111614362326998675040546094339320838419523375986027530441562135724301
q: 13407807929942597099574024998205846127479365820592393377723561443721764030073778560980348930557750569660049234002192590823085163940025485114449475265364281

Task 2:
p: 25464796146996183438008816563973942229341454268524157846328581927885777969985222835143851073249573454107384461557193173304497244814071505790566593206419759
q: 25464796146996183438008816563973942229341454268524157846328581927885777970106398054491246526970814167632563509541784734741871379856682354747718346471375403
```