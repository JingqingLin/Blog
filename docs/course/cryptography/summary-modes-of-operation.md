> 教材第七章，第八章第四节、第五节。主要考查工作模式，参考[文章](https://cathon.github.io/2016/02/18/block-cihper-mode-of-operation/)

为了将分组密码应用于各种各样的实际应用，NIST 定义了五种“工作模式”。从本质上讲，工作模式是一项增强密码算法或者使算法适应具体应用的技术，如将分组密码应用于数据块组成的序列或者数据流。这五种模式实际上覆盖了大量使用分组密码的应用。

## 五种工作模式

| 模式                | 描述                                                                                          | 典型应用                                    |
| ------------------- | --------------------------------------------------------------------------------------------- | ------------------------------------------- |
| 电码本（ECB）       | 用相同的密钥分别对明文分组独立加密                                                            | 单个数据的安全传输（如一个加密密钥）        |
| 密文分组链接（CBC） | 加密算法的输入是上一个密文组和下一个明文组的异或                                              | 1. 面向分组的通用传输 2. 认证               |
| 密文反馈（CFB）     | 一次处理 $s$ 位，上一块密文作为加密算法的输入，产生的伪随机数输出与明文异或作为下一单元的密文 | 1. 面向数据流的通用传输 2. 认证             |
| 输出反馈（OFB）     | 与 CFB 类似，只是加密算法的输入是上一次加密的输出，且使用整个分组                             | 噪声信道上的数据流的传输（如卫星通信）      |
| 计数器（CTR）       | 每个明文分组都与一个经过加密的计数器相异或。对每个后续分组计数器递增                          | 1. 面向分组（？）的通用传输 2. 用于高速需求 |

工作模式的评价标准：
- 总体比较：与 ECB 模式相比，用于加密和解密需要额外的操作
- **错误恢复**：第 $i$ 个密文分组的错误会只被模式同步后的一些（少数）明文分组继承
- **⭐⭐⭐ 错误传播**：第 $i$ 个密文分组的错误会被第 $i$ 组及其后所有明文分组继承
- 扩散：明文统计如何反映在密文中
- 安全性：密文分组是否会泄露关于明文分组的信息

<!-- tabs:start -->

### ** 电码本（ECB） **

![](_images/summary-modes-of-operation-1.png ':size=70%')

- 每个消息块都使用相同的密钥独立加密，因此相同的明文块会被加密成相同的密文块，不能很好地隐藏数据模式

> [!NOTE|label:错误传播]
> 密文传输中的比特错误会在相应的明文分组中造成比特错误，不过这种错误对其他分组没有影响（参考解密流程图）
> 
>![](_images/summary-modes-of-operation-2.png ':size=70%')

### ** 密文分组链接（CBC） **

![](_images/summary-modes-of-operation-3.png ':size=70%')<font size="2" color="#c0c0c0">IV（Initialization Vector，初始向量）</font>


- 它的主要缺点在于加密过程是串行的，无法被并行化
- 和 ECB 一样，CBC 下的消息必须被填充到块大小的整数倍，解决这个问题的一种方法是利用[密文窃取](https://zh.wikipedia.org/wiki/%E5%AF%86%E6%96%87%E7%AA%83%E5%8F%96)

> [!NOTE|label:错误传播]
> 传送过程中密文分组 $C_i$ 的比特错误，在解密时会造成明文分组 $P_i$ 以及下一个明文分组 $P_{i+1}$ 的比特错误，不会影响到其它明文分组。密文分组重复和分组缺失情况见下图：
> 
>![](_images/summary-modes-of-operation-4.png ':size=70%')

### ** 密文反馈（CFB） **

![](_images/summary-modes-of-operation-5.png ':size=70%')

- 与 CBC 相似，明文的改变会影响接下来所有的密文，因此加密过程不能并行化，但解密过程是可以并行化的

> [!NOTE|label:错误传播]
> 密文中一位数据的改变会影响 $1 + b/s$ 个明文分组：对应明文分组中的一位数据与后 $b/s$ 分组中全部的数据。密文分组重复和分组缺失情况见下图：
> 
>![](_images/summary-modes-of-operation-6.png ':size=70%')

### ** 输出反馈（OFB） **

![](_images/summary-modes-of-operation-7.png ':size=70%')

- 每个使用 OFB 的输出块与其前面所有的输出块相关，因此上图中“加密”部分不能并行化处理，但事先算好“加密”部分后，“异或”部分可以并行处理

> [!NOTE|label:错误传播]
> 密文中一位数据的改变仅会影响对应的明文分组。密文分组重复和分组缺失会导致后续解密全错，如下图：
> 
>![](_images/summary-modes-of-operation-8.png ':size=70%')

### ** 计数器（CTR） **

![](_images/summary-modes-of-operation-9.png ':size=70%')

- 加密和解密过程均可以并行处理，CTR 是高速的 OFB

> [!NOTE|label:错误传播]
> 密文中一位数据的改变仅会影响对应的明文分组。密文分组重复和分组缺失会导致后续解密全错（后续每个计数器的值都错了），如下图：
> 
>![](_images/summary-modes-of-operation-10.png ':size=70%')

<!-- tabs:end -->

- ECB 和 CBC 的结果类型是分组密码，而 CFB，OFB 和 CTR 的结果类型是流密码

<!-- 
OFB 不能自同步
-->