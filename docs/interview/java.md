?> Java 基础知识

## 面向过程、面向对象
面向过程：以步骤划分问题  
面向对象：以功能划分问题

## Java 和 C++ 的区别
- Java 不提供指针来直接访问内存，程序内存更加安全（C++ 指针可以做运算）
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承
- Java 有自动内存管理机制，不需要程序员手动释放无用内存

### Java 引用和 C++ 指针
- Java 引用不会产生内存泄露，C++ 指针容易产生内存泄露
- C++ 指针可以做运算

## 多态、封装、继承
封装：封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法

继承：是为了重用父类代码

多态：接口的多种不同的实现方式即为多态，也可以理解为事物存在的多种体现形态（父类的引用类型变量指向了子类对象，或者是接口的引用类型变量指向了接口实现类的对象）
- 条件：1.要有继承 2.要有方法的重写 3.父类引用指向子类对象

## 多重继承、多继承、接口、抽象类
- <img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting/img/1071674-20170503202357211-1434735748.png" width="50%"/>

- 多继承就是一个类继承了多个类（Java 中不允许）
- 接口
  - Java 中可以实现多个接口
  - 接口中只能做方法声明（Java 8 开始接口方法可以有默认实现）
  - 接口中的变量只能 public static。（假设有两个接口 A 和 B，而类 C 实现了接口 A 和 B。假设，此时，A 和 B 中都有一个变量 N，如果 N 不是 static 类型的，那么在 C 中该如何区分 N 到底是 A 的还是 B 的呢？而，如果是 static 类型的，我们可以通过 A.N 和 B.N 来区别调用 A 或者 B 中的成员变量 N）
- 抽象类
  - 不能实例化对象（接口也不行）
  - 抽象类中可以实现方法（可以有非抽象方法）

## 重写(Override)、重载(Overload)
- **重写**（子类重写父类方法）返回值和形参都不能改变（同名同参）

- **重载**是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同（同名不同参，返回值无关）
  - 无法以返回值类型作为重载函数的区分标准

## Java static 方法不能直接调用非 static 方法和属性
一个方法用 static 修饰，便是静态方法或类方法。静态方法不属于特定对象。

由于 static 方法在装载 class 时完成，比构造方法早，此时非 static 属性和方法还没有完成初始化


## 基本类型和引用类型区别
- 赋值方法不同，基本类型直接赋值，引用类型通过 new 创建对象，然后再把对象赋予相应的变量
- 比较方面的不同，== 号的比较：引用类型比较的是引用地址，基本类型比较的是值
- 在数据做为参数传递的时候，基本数据类型是值传递，而引用数据类型是引用传递（地址传递）
- **分别放在 JVM 的哪里**？  
  基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在**栈**上  
  引用数据类型在被创建时，首先要在**栈**上给其引用（句柄）分配一块内存，而对象的具体信息都存储在**堆**内存上，然后由栈上面的引用指向堆中对象的地址

## final
- final 修饰的类叫最终类，该类不能被继承
- final 修饰的方法不能被重写
- final 修饰的变量不可更改。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象

finally 一般作用在 try-catch 代码块中，表示不管是否出现异常，该代码块都会执行

## String、StringBuffer 和 StringBuilder
### 可变性
String 不可变
#### 如何实现不可变
1. `private final byte[] value`。final 修饰 value，所以 value 的**引用**不能改变
2. 同时 String 并没有提供接口来改变 value 的**值**，所以 value 的值我们从 String 外部获取不到，也改变不了

这才是String 才是不可变的真正原因，并不仅仅是使用 final 修饰了 value 数据
#### 为什么设置为不可变
- 为了实现字符串常量池（只有当字符是不可变的，字符串池才有可能实现）
- 为了线程安全（字符串自己便是线程安全的）
- 为了保证同一个对象调用 hashCode() 都产生相同的值，String 设置为不可变可以对这个条件有很好的支持，这也是 Map 类的 key 使用 String 的原因

### 线程安全性
String 中的对象是不可变的，也就可以理解为常量，线程安全。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的

### 性能
StringBuilder > StringBuffer > String

对于三者使用的总结：
- 操作少量的数据: 适用 String
- 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder
- 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer

## hashCode()
hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值

在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等

HashSet 和 HashMap 等集合类使用了 hashCode() 方法来<span style="color: red">计算对象应该存储的位置</span>，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法

## 缓存池和字符串常量池
### 缓存池
`new Integer(123)` 与 `Integer.valueOf(123)` 的区别在于：
- `new Integer(123)` 每次都会新建一个对象
- `Integer.valueOf(123)` 会使用缓存池中的对象，多次调用会取得同一个对象的引用

`valueOf()` 判断值是否在缓存池中，如果在的话就直接返回缓存池的内容，不在就新建一个
### 字符串常量池（String Pool）
String Pool 保存着所有字符串字面量（literal strings）

字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价。JVM 为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在 JVM 中创建的字符串的数量，字符串类维护了一个字符串池，每当代码创建字符串常量时，JVM 会首先检查字符串常量池。如果字符串已经存在池中，就返回池中的实例引用。如果字符串不在池中，就会实例化一个字符串并放到池中。Java 能够进行这样的优化是因为字符串是不可变的，可以不用担心数据冲突进行共享

- new String("abc") 会创建一个或两个对象（若字符串常量池中还没有 "abc" 字符串对象，就会创建两个，常量池内和外都会创建一个）  
  "abc" 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 "abc" 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。

## 反射（不太懂）
反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁

**举例**：当我们在使用 IDE 时，输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。反射最重要的用途就是开发各种通用框架

缺点：效率低

## 异常
<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/exception.jpg" width="70%"/>

- 运行时异常将由 Java 运行时系统自动抛出，允许应用程序忽略运行时异常
- 单个的代码段可能引起多个异常，我们需要定义两个或者更多的 catch 子句

https://www.cnblogs.com/Qian123/p/5715402.html
### 关键字
- try：用于监听。将要被监听的代码放在 try 语句块之内，当try语句块内发生异常时，异常就被抛出
- catch：用于捕获异常。用来捕获 try 语句块中发生的异常
- finally：finally 语句块总是会被执行。它主要用于回收在 try 块里打开的物力资源（如数据库连接、网络连接和磁盘文件）。只有 finally 块，执行完成之后，才会回来执行 try 或 catch 块中的 return 或者 throw 语句，如果 finally 中使用了 return 或 throw 等终止方法的语句，则就不会跳回执行，直接停止
- throw：用于抛出异常
- throws：用在方法签名中，用于声明该方法可能抛出的异常

## 泛型
泛型类、泛型方法、泛型接口。数据类型参数化

泛型的好处是在编译的时候检查类型安全

泛型只在编译阶段有效

泛型擦除

## 注解
Java 注解可以在**类、字段变量、方法、接口**等位置进行一个特殊的标记，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。也可以，代码生成、数据校验、资源整合等工作做铺垫

@target \\ @retention 是元注解。元注解是注解的注解

https://www.bilibili.com/read/cv4802402

## 为什么 main 方法是静态的
如果 main 方法不声明为静态的，JVM 就必须创建包含这个 main 方法的类的实例，创建实例要调用构造方法，若构造方法（<span style="color: red;">构造方法可以重载，不能重写</span>）有参数，JVM 就不知道传什么样的参数去实例化对象

```java
public class JavaClass {
  protected JavaClass(int x) {}
  public void main(String[] args) {
  }
}
```

静态变量初始化是在类加载过程的准备阶段，具体看 JVM 部分笔记：https://blog.csdn.net/shenjianzhuang/article/details/79044478?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

## 为什么要父类引用指向子类对象
为了实现多态。有多个子类，只需改变引用就能实现不同的功能