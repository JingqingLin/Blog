- 电路交换、分组交换  
<img src="https://i.loli.net/2020/03/14/5U96sYfqRXWZQkv.png" width="70%">

- 电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送
- 分组交换：单个分组传送到相邻结点，传送到相邻结点，存储下来后查找转发表，转发到下一个结点


## 五层模型
- 应用层：为用户的应用进程提供服务。协议：DHCP、DNS、HTTP、FTP 等
- 传输层：TCP、UDP
- 网络层：
  - ARP（地址解析协议）：根据IP地址获取 Mac 地址
  - ICMP（Internet 控制报文协议）：ping / traceroute。用于在 IP 主机、路由器之间传递一些控制消息，控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息
- 数据链路层：点对点协议、停止等待协议（TCP 保证传输可靠的重要途径）
- 物理层：


<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting/img/20200311161048.png" width="70%"/>

## 物理层（比特）

## 数据链路层（帧）
### 基本问题
- 封装成帧
- 透明传输
- 差错检测：循环冗余检验

### 信道分类
- 广播信道
- 点对点信道

### 信道复用技术
- 频分复用
- 时分复用
- 统计时分复用
- 波分复用：光的频分复用
- 码分复用

## 网络层

## 传输层
### TCP 首部
- 序号 seq：用于对字节流进行编号
- 确认号 ack：**期望收到的下一个报文段的序号**
- 确认位 ACK：在**连接建立后**所有传送的报文段都必须把 ACK 置 1
- 同步位 SYN：在**连接建立时**用来同步序号
- 终止位 FIN：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接

### TCP 的三次握手
<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting/img/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="80%"/>

https://zhuanlan.zhihu.com/p/102197175

> 第三次握手：让我（服务器）知道你（客户）已经知道了

- 最后一次握手，客户端可以携带数据
- 为什么客户端最后还要发送一次确认（为什么是三次握手而不是两次）？  
    - 主要防止已经失效的连接请求报文突然又传送到了服务器，再次建立连接。这将导致不必要的错误和资源的浪费。  
    什么是<span style="color:red;">已失效的连接请求</span> ——> 客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，那么之前的那条请求就失效了

- 第三次握手时 ACK 丢失怎么办？
  - 当 Client 端收到 Server 的 SYN+ACK 应答后，其状态变为 ESTABLISHED，并发送 ACK 包给 Server  
  如果此时 ACK 在网络中丢失，那么 Server 端该 TCP 连接的状态为 SYN_RECV，并且依次等待 3 秒、6 秒、12 秒后重新发送 SYN+ACK 包，以便 Client 重新发送 ACK 包，以便 Client 重新发送 ACK 包  
  如果重发指定次数后，仍然未收到 ACK 应答，那么一段时间后，Server 自动关闭这个连接。

### TCP 的四次挥手
<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting/img/图片.png" width="80%"/>

- 为什么建立连接是三次握手，关闭连接确是四次挥手？  
  客户端发送了 FIN（finish）连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送<span style="color:red;">还未传送完毕的数据</span>，传送完毕之后，服务器会发送 FIN 连接释放报文。
- 为什么客户端最后还要等待 2MSL？  
  1. 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。  
  2. 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

#### 如果已建立连接，但客户端突然出现故障怎么办？
TCP 还设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接


### TCP 如何实现可靠传输
1. 校验：增加伪首部
2. 序号
3. 确认：累计确认（连续收到几个报文段，再返回确认信息。区别于停等协议）。接收方返回确认号字段（期望下一个报文段的序号，也可以理解为这个序号前的全部报文段我已经接受了）
4. 重传：超时重传、快速重传（接收到三个冗余 ack）

<img src="https://i.loli.net/2020/04/04/cOfzGlIA4yQi3oj.png" width="50%">

### ⭐ TCP 流量控制
接收方发送 rwnd（接收窗口）给发送方

$发送窗口 = \min(接受窗口, 拥塞窗口)$

### ⭐ TCP 拥塞控制
> 拥塞控制解决指的是传输路径的拥塞，流量控制是用来适应接收方的接收能力（缓存区）。流量控制是一对一的

#### 慢开始与拥塞避免

<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/171445eb63af609b.png" width="70%"/>

ssthresh：慢开始门限

#### 快重传与快恢复

<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/1714473e4f8f0eb1.png" width="70%"/>

## 应用层
### 状态码：

<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/1633e19dba27ed00.png" width="70%"/>

### HTTP
Web 浏览器与 Web 服务器之间**请求和应答**的标准，通常使用 TCP 协议

客户端发起一个 HTTP 请求到服务器上指定端口。HTTP 服务器则在那个端口**监听**客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息

### 如何理解 HTTP 协议是无状态的
协议对于事务处理没有记忆能力，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系

#### 让服务器有记忆能力之 Cookie、Session
Session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 Session 保存在服务器上

### HTTP 长连接、短连接（本质是 TCP）
长连接：客户端和服务器建立连接后，会在一段时间内保持连接，这段时间内可以进行多次数据传输。**HTTP/1.1 规定了默认保持长连接**

短连接：客户端与服务器每进行一次数据传输都会建立连接，传输完毕后立即断开连接

### HTTP 请求报文、响应报文
HTTP 请求报文主要由
- 请求行：请求方法、URL 以及协议版本
- 请求头部：请求头部为请求报文添加了一些附加信息
- 请求正文（可选，GET 方法就没 body）

HTTP 响应报文主要由
- 状态行：协议版本，状态码，状态码描述
- 响应头部
- 响应正文

## 一些小点
- 输入 URL 后发生了什么？https://juejin.im/post/5b5f20686fb9a04f844adbdd#heading-14
  1. 域名解析
  2. 建立 TCP 连接
  3. 浏览器向服务器发送 HTTP 请求
  4. 服务器处理请求
  5. 关闭 TCP 连接
  6. 浏览器渲染

- HTTP 和 HTTPS 的区别
  - **端口** ：80 和 443
  - **安全性和资源消耗：** HTTPS 是 HTTP 和 SSL 组合而成的，在传输层使用了 SSL 进行加密

- GET 和 POST 区别
  - 从服务器获得资源 / 向服务器提交资源
  - 携带数据的格式：GET 请求没有 body，只有 url，请求数据放在 url 的 querystring 中；POST 请求的数据在 HTTP 的 body 中

- TCP 和 UDP 区别
  - TCP 是面向连接的，UDP 是面向无连接的
    - 面向连接的协议会先建立连接，如 TCP 有三次握手，而 UDP 不会
  - TCP 是**面向字节流**的，UDP 是基于**数据报**的
  - TCP 保证数据正确性
  - TCP 保证数据顺序，UDP 不保证

- HTTP 2.0：并行发送数据，多路复用

- 端口：标识主机中的应用进程

- 服务器 TIME_WAIT 状态过多
  - **影响**：会占用大量的端口号
  - **原因**：高并发、短连接、服务器主动关闭连接（应尽量由客户端主动关闭连接）
    - 短连接：取一个 web 页面，1 秒钟的 HTTP 短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在 TIME_WAIT 状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的（占着茅坑不拉翔）