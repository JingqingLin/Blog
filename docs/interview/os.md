<span style="font-size: 18px;font-weight: bold">用户态、内核态</span>

- 用户态：CPU 只能执行非特权指令
- 核心态：特权、非特权都可以执行

**特权指令**不允许用户程序使用

🌟 **访管指令**是一条可以在目态下执行的指令，用户程序中凡是要调用操作系统功能时就安排一条访管指令。当处理器执行到访管指令时就产生一个中断事件（自愿中断），暂停用户程序的执行，而让操作系统来为用户服务

原子（atom）本意是“不能被进一步分割的最小粒子”，而**原子操作**（atomic operation）意为“不可被中断的一个或一系列操作”

## 线程管理
进程是资源分配的最小单位，线程是 CPU 调度的最小单位。一个进程中可以有多个线程，与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**（JVM 中运行时数据区的分区），所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多

### ⭐⭐ 进程调度算法
先来先服务、短作业优先（饥饿）、最短剩余时间优先、高响应比优先（动态调整优先级，<span style="font-size: 13px;color: gray">优先级 = （作业已等待时间 + 作业的服务时间） / 作业的服务时间）</span>  
时间片轮转、优先级调度、多级反馈队列

时间片轮转：时间片过小，则进程频繁切换，会造成 CPU 资源的浪费；时间片过大，则轮转调度算法就退化成了先来先服务算法

### 进程同步
一次仅允许一个进程使用的资源称为**临界资源**  

同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系  
互斥：多个进程在同一时刻只有一个进程能进入临界区


### ⭐⭐ 进程通信
进程同步与进程通信很容易混淆，它们的区别在于：进程同步：控制多个进程按一定顺序执行；进程通信：进程间传输信息

1. <span style="color: red">管道</span>（pipe）：管道是一种半双工的通信方式，只能在具有亲缘关系的进程间使用。*进程的亲缘关系通常是指父子进程关系或者兄弟进程之间*。
2. 命名管道（named pipe, FIFO）：命名管道也是半双工的通信方式，但是它允许无亲缘关系的进程间的通信。
3. <span style="color: red">消息队列</span>（message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓存区大小受限等缺点。
4. <span style="color: red">共享内存</span>（shared memory）：<span style="color: red">共享内存就是映射一段能被其他进程所访问的内存</span>，这段共享内存由一个进程创建，但多个进程都可以访问。<span style="color: red">共享内存是最快的 IPC（进程间通信）方式，因为无需在进程和内核之间复制数据</span>。两个进程对共享空间的访问必须是互斥的，所以一般配合信号量使用，来实现进程间的同步和通信。
5. <span style="color: red">套接字（socket）</span>：套接字也是一种进程间通信的机制，与其他通信机制不同的是，它可用于<span style="color: red">不同机器间</span>的进程通信


## 死锁

> 对不可剥夺资源的不合理分配，会导致死锁

互相等待对方手里的资源，导致各自进程阻塞，都无法向前推进。

#### 必要条件
- 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁
- 不剥夺条件
- 请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
- 循环等待条件（按序申请资源来预防）：若干进程之间形成一种头尾相接的循环等待资源关系

#### 处理策略
- 预防死锁：破坏四个必要条件
- 避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁
（银行家算法）
- 死锁的检测与解除

## 内存管理

⭐👇🏿

<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/muMCeExdaznfRYT.png" width="70%"/>

<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/1715f823df15c66d.png" />

上图中：
- 动态分区分配算法有：首次适应、循环首次适应、最佳适应、最坏适应

- **连续分配管理的三种方式，会有不同的碎片情况（见上图）；非连续分配中的分页式存储管理中会产生内部碎片**

- **外部碎片**指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域

- 基本分页、分段算法是**内存的非连续分配**方式

- 虚拟内存（内存扩充技术）使用了空分复用技术。即，*程序不需全部装入即可运行，运行时根据需要动态调入数据，若内存不够，换出一些数据*。（基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就能启动程序执行。在程序执行过程中，*当访问的信息不在内存时*，将所需要的部分调入内存，然后继续执行程序。另一方面，将内存中暂时不使用的内容换出到外存上。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。）

<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/1285650-20180103113052799-1386920559.png"/>

### ⭐ 逻辑地址（相对地址）
进程在内存中的起始地址是不确定的，因此进程中的变量在内存中的存放位置要用相对地址表示

逻辑地址存放在指令中
- （用户进程的地址空间）逻辑地址空间分为若干页；物理内存空间分为若干页框

### 物理地址
变量在内存中实际存放的地址

### 基本分页存储管理

> 非连续的内存分配方式

- 逻辑地址如何转为物理地址？
  1. 求出逻辑地址所在页号
  2. 页面在内存中的起始地址
  3. 求逻辑地址在页面内的偏移量
  4. 物理地址 = 页面始址 + 偏移量

#### 页表
<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/20200403171104.png" width="70%"/>

块号就是页框号

### 基本分段存储管理

> 非连续的内存分配方式

分段是按逻辑功能模块划分的

<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/20200403171716.png" width="70%"/>

- 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序

### 页面置换算法（请求分页存储管理）
<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/20200403173507.png" width="70%"/>

- 最佳置换算法（OPT）：选择以后永不使用，或者最长时间内不被访问的页面。（计算机中无法实现）  
- 先进先出置换算法（FIFO）：字面意思，算法性能差，会有 Belady 异常  
- **最近最久未使用置换算法（LRU）**：每次淘汰的页面是最近最久未使用的页面。局部性原理。`LinkedHashMap`，C++ 中无此类数据结构，可通过哈希表 + 双向链表（因为删除尾节结点时要把前一个结点赋给尾结点）实现
- 时钟置换算法（没看）  

## 设备管理
### 磁盘调度算法
- 先来先服务
- 最短寻道时间优先（饥饿）
- 电梯算法