?> 翻译自：[Why Not Specialize Function Templates?](http://gotw.ca/publications/mill17.htm)。周会上 liangxinglun 同学分享了这片文章，觉得很不错，于是尝试翻译一下

---

虽然这篇文章的标题是一个疑问句，但它也可以变成一个陈述句：什么时候特化模板以及为什么不特化模板。

## 重要的区别：重载（Overloading）和特化（Specialization）

为了确保我们熟悉相关术语，因此在这里对这些术语做一个快速回顾。

在 C++ 中，有*类模板*和*函数模板*。这两种模板的工作方式并不完全相同，最明显的区别就是重载：C++ 中的 [POD](https://en.wikipedia.org/wiki/Passive_data_structure) 类无法重载，因此类模板也无法重载；另一方面，C++ 中具有相同函数名的 POD 函数可以重载，因此函数模板也被允许重载。上面的逻辑很自然。我们在例 1 中总结了上面的结论：

```cpp
// 例 1: 类模板 vs 函数模板，以及重载 
//

// 类模板
template<class T> class X {/*...*/};      // (a)

// 函数模板及其重载
template<class T> void f(T);              // (b)
template<class T> void f(int, T, double); // (c)
```

这些未被特化的模板也叫做基模板（underlying base templates）。

此外，基模板是可以被特化的。这就是类模板和函数模板进一步的不同之处，在本文后续中会变得很重要。一个类模板可以被[部分特化](https://zh.cppreference.com/w/cpp/language/partial_specialization)（也被译为偏特化）和[显式（全）特化](https://zh.cppreference.com/w/cpp/language/template_specialization)。一个函数模板只能被显式特化，但是由于函数模板可以重载，通过重载，我们可以获得与部分特化几乎相同的效果<sup>[1]</sup>。以下代码说明了这些差异：

<font size="2">注<sup>[1]</sup>：下文中将使用偏特化和全特化的译法。</font>

```cpp
// 例 1（续）：特化模板
//

// 模板 (a) 对指针类型的偏特化
template<class T> class X<T*> {/*...*/};

// 模板 (a) 对 int 的全特化
template<> class X<int> {/*...*/};

// 单独的基模板，它重载了模板 (b) 和 (c)--不是
// (b) 的偏特化, 因为函数模板的偏特化是不存在的
template<class T> void f(T*);             // (d)

// 模板 (b) 对 int 的全特化
template<> void f<int>(int);              // (e)

// POD 函数对模板 (b)，(c) 和 (d) 的
// 重载——但不是 (e), 我们会在稍后讨论
void f(double);                           // (f)
```

最后，让我们只关注函数模板，并考虑重载规则，看看在不同的情况下会调用哪个模板。这些规则非常简单，至少在较高的级别上是如此，并且可以表示为经典的两级制：

> - 非模板函数是首选。对于一个 POD 非模板函数，如果它的参数类型和函数模板一样都能匹配上，那么它就会被选中，而不是选择其他的函数模板
> - 如果不存在那样的首选，那么接下来函数基模板将作为次选会被参考。哪一个函数基模板被选中，取决于哪一个最匹配，而且是“最特化（most specialized）”的（重要提示：这个“特化”的用法很奇怪，与模板特化没有任何关系，它只是一种不恰当的口语），根据一套相当玄妙的规则：
>   - 如果很明显有一个“最特化”的函数基模板，那么就使用这个模板。如果该基模板恰好针对所使用的类型进行了特化，则使用特化模板，否则，将使用以正确类型实例化的基模板
>   - 否则，如果“最特化”函数基模板的匹配出现了平手，那么调用是不明确的，因为编译器不能决定哪个是更好的匹配。程序员将必须做一些事情来限定调用，并说明需要调用哪个
>   - 如果没有可以匹配的函数基模板，调用将是错误的，程序员必须修复代码

以下示例把这些规则放在了一起：

```cpp
// 例 1（续）：重载解析
// 
bool b;
int i;
double d;

f(b);        // 调用模板 (b)，其中 T = bool
f(i, 42, d); // 调用模板 (c)，其中 T = int
f(&i);       // 调用模板 (d)，其中 T = int
f(i);        // 调用模板 (e)
f(d);        // 调用模板 (f)
```

到目前为止，我特意选择了较简单的例子，便于我们由浅入深地理解。

## 为什么不特化：一个来自 Dimov 和 Abrahams 的例子

考虑以下代码：

```cpp
// 例 2：全特化 
// 
template<class T> // (a) 是一个基模板
void f(T);

template<class T> // (b) 是另一个基模板, 并重载了 (a)
void f(T*);       // （函数模板不能偏特化，只能重载）

template<>        // (c) 是 (b) 的全特化
void f<>(int*);

// ...

int *p;
f(p);             // 调用 (c)
```

例 2 中最后一行的结果正是你所期望的。然而，今天的问题是，你为什么期望这个结果。如果你的解释是错误的，你会对接下来发生的事情感到非常惊讶。毕竟，有人会说：“那又怎样，我为一个指向 int 的指针写了一个特化，所以很明显这就是应该被调用的”——这正是错误的原因。

现在考虑以下代码，由 Peter Dimov 和 Dave Abrahams 编写：

```cpp
// 例 3：Dimov 和 Abrahams 的例子 
// 
template<class T> // (a) 和之前一样的基模板
void f(T);

template<>        // (c) 这次是 (a) 的全特化，因为此时 (b) 还没有被定义
void f<>(int*);

template<class T> // (b) 是另一个基模板, 并重载了 (a)
void f(T*);

// ...

int *p;
f(p);             // 调用 (b)！重载解析忽略特化，只对基函数模板进行操作
```

如果这让你感到惊讶，你并不是一个人；这让当时的许多专家也感到惊讶。理解这一点的关键很简单，这就是：特化的模板不能重载。

只有基模板可以重载（当然还有非模板函数）。再次考虑我在上面的总结中给出的重载解析规则的突出部分，这一次强调了一些具体的词语：

> ...
> 
> - 如果不存在那样的首选，那么接下来*函数基模板*将作为次选会被参考。哪一个函数基模板被选中，取决于哪一个最匹配，而且是“最特化（most specialized）”的...根据一套相当玄妙的规则：
>   - 如果很明显有一个“最特化”的函数基模板，那么就使用这个模板。如果该基模板恰好针对所使用的类型进行了特化，则使用特化模板，否则，将使用以正确类型实例化的基模板
>   - ...

重载解析只选择一个基模板（或者一个非模板函数，如果有的话）。只有在确定了要选择哪个基模板之后，编译器才会四处查看是否有合适的特化模板可用，如果有，就会使用特化模板。

## 重要启示

如果你和我一样，第一次看到这种情况，你会问：“嗯。但在我看来，我专门为参数是 `int*` 的情况编写了一个特化模板，它是一个 `int*` 的精确匹配，所以我的特化模板不应该总是被使用吗？”唉，这是一个错误：如果你希望确保在精确匹配的情况下始终使用它，那么 POD 函数就是用于此目的的——因此只需将其写成一个非模板函数而不是一个特化模板。

特化模板不能重载的理由很简单，之前解释过，因为令人惊讶的因素恰恰相反：标准委员会认为，仅仅因为你碰巧为某个模板编写了特化模板，它就会以任何方式改变所使用的模板，这是令人惊讶的。在这个理由下，既然我们已经有办法确保我们想要的版本被使用（我们只需将其写成一个非模板函数而不是一个特化模板），我们就可以更清楚地理解为什么特化不会影响模板的选择。

- 启示 #1：如果你想要定制一个基于函数的模板，并希望参与重载解析（或者在完全匹配的情况下使用），请使其成为 POD 函数，而不是特化模板。而且，如果你确实提供了重载，请避免同时提供特化模板

但是如果你是一个编写，而不仅仅是使用函数模板的人呢？为了你自己和你的用户，你能做得更好并避免这个（和其他）问题吗？实际上，你可以：

- 启示 #2：如果你正在编写一个函数基模板，最好将其编写为一个永远不应该特化或重载的单一函数模板，然后将函数模板完全作为一个简单的类模板来实现，该类模板包含具有相同签名的静态函数。每个人都可以特化它——全特化和偏特化，并且不会影响重载解析的结果

```cpp
// 例 4：阐述启示 #2
// 
template<class T>
struct FImpl;

template<class T>
void f(T t) {FImpl<T>::f(t);} // 用户不要动它

template<class T>
struct FImpl                  // 用户可以特化它
{
  static void f(T t);         
};
```

## 总结

重载函数模板是可以的。重载解析同等地考虑所有基模板，因此它的工作原理与你处理普通 C++ 函数重载一样：任何可见的模板都将被用于重载解析，编译器只会选择最佳的匹配项。

对函数模板进行特化就不那么直观了。首先，你不能对它们进行部分特化 -- 几乎只是因为语言说你不能。还有一点，函数模板的特化不会重载。这意味着你写的任何特化都不会影响哪个模板被使用，这与大多数人的直觉预期是相反的。毕竟，如果你写了一个具有相同签名的非模板函数而不是特化的函数模板，非模板函数总是会被选中，因为它总被认为是比模板更好的匹配。

如果你要写一个函数模板，最好把它写成一个单一的函数模板，永远不要特化或重载，完全用类模板来实现函数模板。这就是众所周知的中间层，它能很好地引导你远离函数模板的局限性和黑暗角落。这样一来，使用你模板的程序员就可以在不影响函数模板预期操作的前提下，尽情地对类模板进行部分特化和显式特化。这样既避免了函数模板不能部分特化的局限性，又避免了函数模板特化有时不会重载的惊人效果。问题解决了。

如果你使用的是别人的普通函数模板（没有按照上面的建议用类模板来实现的），而你又想自己写一个应该参与重载的特例版本，就不要把它写成特化模板，只要把它写成一个重载的非模板函数，用同样的签名就可以了。

## 鸣谢

感谢 Peter Dimov 和 Dave Abrahams 鼓励我写关于这个主题的文章，并提供了关键的例子，感谢 John Spicer 帮助我理清了原理。

## 说明

1. 在标准术语中，全特化称为“显式特化”
2. 委员会内部正在讨论下一个版本的 C++ 标准是否允许函数模板偏特化，这些工作正在进行中